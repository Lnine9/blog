---
title: useInView
description: useInView
tags: react, IntersectionObserver
date: 2023/5/4
---

> IntersectionObserver æ¥å£ï¼ˆä»å±äº Intersection Observer APIï¼‰æä¾›äº†ä¸€ç§å¼‚æ­¥è§‚å¯Ÿç›®æ ‡å…ƒç´ ä¸å…¶ç¥–å…ˆå…ƒç´ æˆ–é¡¶çº§æ–‡æ¡£è§†å£ï¼ˆviewportï¼‰äº¤å‰çŠ¶æ€çš„æ–¹æ³•ã€‚å…¶ç¥–å…ˆå…ƒç´ æˆ–è§†å£è¢«ç§°ä¸ºæ ¹ï¼ˆrootï¼‰ã€‚
>
> --MDN https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver

åšç½‘é¡µå¼€å‘æ—¶ç»å¸¸ä¼šé‡åˆ°ä¸€ä¸ªéœ€æ±‚ï¼Œå°±æ˜¯åˆ¤æ–­å…ƒç´ æ˜¯å¦å‡ºç°ã€‚æ¯”å¦‚å›¾ç‰‡å‡ºç°æ—¶åŠ è½½ã€å…ƒç´ å‡ºç°æ—¶æ’­æ”¾åŠ¨ç”»...
ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨**getBoundingClientRect**æ–¹æ³•

```js
function isInViewPort(element) {
  const viewWidth = window.innerWidth || document.documentElement.clientWidth;
  const viewHeight =
    window.innerHeight || document.documentElement.clientHeight;
  const { top, right, bottom, left } = element.getBoundingClientRect();

  return top >= 0 && left >= 0 && right <= viewWidth && bottom <= viewHeight;
}

window.addEventListener("scroll", () => {
  if (isInViewPort(element)) {
    // ...do something
  }
});
```

ä¸è¿‡ scroll äº‹ä»¶ä¼šæœ‰å¤§é‡è®¡ç®—ï¼Œé€ æˆèµ„æºæµªè´¹ï¼Œå¼•èµ·é¡µé¢å¡é¡¿

## ä¸‹é¢æ˜¯ç”¨ IntersectionObserver å®ç°çš„ä¸€ä¸ª useInView çš„ hook

```ts
import { RefObject, useEffect, useState } from "react";

interface Options {
  /**
   * æµ‹è¯•äº¤å‰æ—¶ï¼Œç”¨ä½œè¾¹ç•Œç›’çš„å…ƒç´ æˆ–æ–‡æ¡£ã€‚
   * å¦‚æœæ„é€ å‡½æ•°æœªä¼ å…¥ root æˆ–å…¶å€¼ä¸ºnullï¼Œåˆ™é»˜è®¤ä½¿ç”¨é¡¶çº§æ–‡æ¡£çš„è§†å£ã€‚
   */
  root?: RefObject<Element>;
  /**
   * è®¡ç®—äº¤å‰æ—¶æ·»åŠ åˆ°æ ¹è¾¹ç•Œç›’ (en-US)çš„çŸ©å½¢åç§»é‡ï¼Œå¯ä»¥æœ‰æ•ˆçš„ç¼©å°æˆ–æ‰©å¤§æ ¹çš„åˆ¤å®šèŒƒå›´ä»è€Œæ»¡è¶³è®¡ç®—éœ€è¦ã€‚
   * æ­¤å±æ€§è¿”å›çš„å€¼å¯èƒ½ä¸è°ƒç”¨æ„é€ å‡½æ•°æ—¶æŒ‡å®šçš„å€¼ä¸åŒï¼Œå› æ­¤å¯èƒ½éœ€è¦æ›´æ”¹è¯¥å€¼ï¼Œä»¥åŒ¹é…å†…éƒ¨è¦æ±‚ã€‚
   * æ‰€æœ‰çš„åç§»é‡å‡å¯ç”¨åƒç´ ï¼ˆpxï¼‰æˆ–ç™¾åˆ†æ¯”ï¼ˆ%ï¼‰æ¥è¡¨è¾¾ï¼Œé»˜è®¤å€¼ä¸º â€œ0px 0px 0px 0pxâ€ã€‚
   * å¦‚æœæƒ³æå‰100pxè§¦å‘å¯ä»¥è®¾ç½®bottomä¸º100px,å»¶ååˆ™ä¸º-100px
   *
   * ==========è§¦å‘ç¦»å¼€å¯è§†åŒºåŸŸ
   *    100px
   * ----------
   *
   *    çª—å£
   *
   * ----------
   *    100px
   * ========== è§¦å‘è¿›å…¥å¯è§†åŒºåŸŸ
   */
  rootMargin?: string;
  /**
   * ä¸€ä¸ªåŒ…å«é˜ˆå€¼çš„åˆ—è¡¨ï¼ŒæŒ‰å‡åºæ’åˆ—ï¼Œåˆ—è¡¨ä¸­çš„æ¯ä¸ªé˜ˆå€¼éƒ½æ˜¯ç›‘å¬å¯¹è±¡çš„äº¤å‰åŒºåŸŸä¸è¾¹ç•ŒåŒºåŸŸçš„æ¯”ç‡ã€‚
   * å½“ç›‘å¬å¯¹è±¡çš„ä»»ä½•é˜ˆå€¼è¢«è¶Šè¿‡æ—¶ï¼Œéƒ½ä¼šç”Ÿæˆä¸€ä¸ªé€šçŸ¥ã€‚
   * å¦‚æœæ„é€ å™¨æœªä¼ å…¥å€¼ï¼Œåˆ™é»˜è®¤å€¼ä¸º 0ã€‚
   * å¦‚æœä½ æƒ³è¦ target å…ƒç´ åœ¨ root å…ƒç´ çš„å¯è§ç¨‹åº¦æ¯å¤š 25%å°±æ‰§è¡Œä¸€æ¬¡å›è°ƒï¼Œé‚£ä¹ˆä½ å¯ä»¥æŒ‡å®šä¸€ä¸ªæ•°ç»„[0, 0.25, 0.5, 0.75, 1]ã€‚
   */
  threshold?: number[];
  // åªå‡ºç°ä¸€æ¬¡
  once?: boolean;
}

export const useInView = (ref, options?: Options) => {
  const [isInView, setInView] = useState(false);

  useEffect(() => {
    if (!ref.current || (options?.once && isInView)) return;

    const _options = {
      root: (options?.root && options.root.current) || undefined,
      ...options,
    };

    return setup(ref.current, setInView, _options);
  }, [options?.root, ref, options?.rootMargin, options?.once]);

  return isInView;
};

const setup = (element, setInView, options) => {

  const callback = (entries) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        setInView(true);
        if (options.once) {
          observer.unobserve(entry.target);
        }
      } else {
        setInView(false);
      }
    });
  };
  const observer = new IntersectionObserver(callback, options);
  observer.observe(element);
  return () => observer.disconnect();
};
```

æµ‹è¯•

```tsx
"use client";
import React, { useRef } from "react";
import { useInView } from "@/app/hooks/useInView";

const Demo = () => {
  const a = useRef<HTMLDivElement>(null);
  const b = useRef<HTMLDivElement>(null);
  const container = useRef<HTMLDivElement>(null);

  const isAInView = useInView(a, { rootMargin: "-100px 0px 400px 0px" });
  const isBInView = useInView(b, { rootMargin: "-400px 0px -400px 0px" });
  const isContainer = useInView(container);

  return (
    <div
      ref={container}
      className="h-[2000px] flex items-center gap-4 relative"
    >
      <div
        style={{ visibility: isContainer ? "visible" : "hidden" }}
        className="fixed top-20 left-1/2 w-20 bg-neutral-700 bg-opacity-60 text-white"
      >
        <p>{isAInView ? "A is inView" : "A is not inView"}</p>
        <p>{isBInView ? "B is inView" : "B is not inView"}</p>
      </div>
      <div
        ref={a}
        className="w-[200px] h-[200px] bg-emerald-500
         flex justify-center items-center text-3xl"
      >
        A
      </div>
      <div
        ref={b}
        className="w-[200px] h-[200px] bg-rose-500
         flex justify-center items-center text-3xl"
      >
        B
      </div>
    </div>
  );
};

export default Demo;
```

å‘ä¸‹æ»‘åŠ¨ ğŸ‘‡

<UseInViewDemo />
