---
title : TypeScriptå¸¸ç”¨ç±»å‹
description : TypeScriptå¸¸ç”¨ç±»å‹
tags : ts
date : 2023/4/6
---
## Partial
å°†ç±»å‹ä¸­æ‰€æœ‰å±æ€§å˜æˆå¯é€‰çš„
```ts
/**
 * Make all properties in T optional
 */
type Partial<T> = {
    [P in keyof T]?: T[P];
};
```
Partialåªèƒ½ä½œç”¨åˆ°ç¬¬ä¸€å±‚ï¼Œå¦‚æœè¦åµŒå¥—ä½¿ç”¨å¯ä»¥ç”¨ä¸‹é¢çš„è‡ªå®šä¹‰ç±»å‹
```ts
type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends Array<infer U>
    ? Array<DeepPartial<U>>
    : T[P] extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : DeepPartial<T[P]>;
};
```

### inferå…³é”®å­—
**infer**å¯ä»¥åœ¨**extends**çš„æ¡ä»¶è¯­å¥ä¸­æ¨æ–­å¾…æ¨æ–­çš„ç±»å‹

```ts
type Func = (name: string, age: number) => number;

// tsçš„ä¸€ä¸ªå†…ç½®ç±»å‹ï¼Œç”¨æ¥æ¨æ–­å‡½æ•°è¿”å›å€¼ç±»å‹
type ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any;

type funcReturnType = ReturnType<Func>; // ç±»å‹ä¸º number

// tsçš„ä¸€ä¸ªå†…ç½®ç±»å‹ï¼Œç”¨äºæ¨æ–­å‡½æ•°çš„å‚æ•°ç±»å‹
type Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never;

type funcParameters = Parameters<Func>;// ç±»å‹ä¸º [name: string, age: number]
```

## Required
å°†ç±»å‹ä¸­çš„æ‰€æœ‰å±æ€§å˜ä¸ºå¿…å¡«
```ts
/**
 * Make all properties in T required
 */
type Required<T> = {
    [P in keyof T]-?: T[P];
};
```
## Readonly
å°†ç±»å‹ä¸­çš„æ‰€æœ‰å±æ€§å˜ä¸ºåªè¯»
```ts
/**
 * Make all properties in T readonly
 */
type Readonly<T> = {
    readonly [P in keyof T]: T[P];
};
```

## Record
åˆ›å»ºä¸€ä¸ªå…¨éƒ¨å±æ€§å…·æœ‰ç›¸åŒç±»å‹çš„ç±»å‹
```ts
/**
 * Construct a type with a set of properties K of type T
 */
type Record<K extends keyof any, T> = {
    [P in K]: T;
};

const pig: Record<string, string> = {name: 'ğŸ·', address: 'where'}
```

## Exclude
å¦‚æœTèƒ½å¤Ÿå…¼å®¹Uåˆ™è¿”å›neverï¼Œå¦åˆ™è¿”å›Tã€‚ä¸€èˆ¬ç”¨äºä»ä¸€ä¸ªè”åˆç±»å‹ä¸­å‰”é™¤ä¸€äº›ä¸éœ€è¦çš„ç±»å‹
```ts
/**
 * Exclude from T those types that are assignable to U
 */
type Exclude<T, U> = T extends U ? never : T;

type UnionType = "name" | "age" | "size";

const some: Exclude<UnionType, "age" | "size"> = "name";
```

## Extract
ä¸Excludeç›¸åã€‚
```ts
/**
 * Extract from T those types that are assignable to U
 */
type Extract<T, U> = T extends U ? T : never;
```

## Omit
ä¸€èˆ¬ç”¨äºä»ä¸€ä¸ªç±»å‹ä¸­å‰”é™¤ä¸éœ€è¦çš„å±æ€§
```ts
/**
 * Construct a type with the properties of T except for those in type K.
 */
type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;

type Pig = {name: string, size: number}

const pig: Omit<Pig, 'size'> = {name: 'ğŸ·'}
```

## Pick
ä»ç±»å‹ä¸­é€‰å‡ºéƒ¨åˆ†å±æ€§ï¼Œæ¥è¿”å›æ–°çš„å±æ€§
```ts
/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

type Pig = {name: string, size: number}

const pig: Pick<Pig, 'name'> = {name: 'ğŸ·'}
```

## NonNullable
```ts
/**
 * Exclude null and undefined from T
 */
type NonNullable<T> = T & {};

type myType = string | number | null | undefined

type noNullType = NonNullable<myType>
```

## å­—æ¯å¤§å°å†™ç›¸å…³
```ts

/**
 * å…¨éƒ¨å­—æ¯å¤§å†™
 */
type Uppercase<S extends string> = intrinsic;
/**
 * å…¨éƒ¨å­—æ¯å°å†™
 */
type Lowercase<S extends string> = intrinsic;
/**
 * é¦–å­—æ¯å¤§å†™
 */
type Capitalize<S extends string> = intrinsic;
/**
 * é¦–å­—æ¯å°å†™
 */
type Uncapitalize<S extends string> = intrinsic;

// ä¸¾ä¾‹
type Types = 'name'|'size'

type UpperTypes = Uppercase<Types>;// 'NAME'|'SIZE'
```